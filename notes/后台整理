
关于iOS后台执行

1.先说说iOS 应用程序5个状态：

活动-app处于“使用中”的状态。

不活动-应用程序处于前台但不再接收事件（例如，用户在app处于活动时锁住了设备）。

后台-app不再屏幕上显示，但它仍然执行代码。

挂起-app仍然驻留内存但不再执行代码。（按下Home键时，app从活动状态转入后台，绝大部分app通常在几秒内就从后台变成了挂起。）

停止运行-应用程序已经终止，或者还未启动。（在内存吃紧的时候，iphone会首先关闭那些挂起的app。）

控制它是否后台运行：
从 iOS 4 开始，应用就可以在退到后台后，继续运行一小段时间（10 分钟）；ios7之后 申请一次就只有180秒了，最大累计时间不超过600秒，
1.默认创建的工程，Application does not run in background默认为NO, 此时的application.backgroundTimeRemaining是180s.
2.如果info.plist里面Application does not run in background设置为YES，打印application.backgroundTimeRemaining还是180s., 但是一切入后台，XCODE调试的工程会马上停止。
Application does not run in background设置为NO 开:（实测 秒）
  限时地运行:
Background Task  Completion
这个接口早在iOS 4时候便拥有，其可以供任意类型的APP使用，不过在旧系统中，这个接口的后台限制运行时间仅为10分钟，意味着当应用退至后台，其后台运行仅能持续10分钟便会转至休眠状态。iOS 7中对这个接口作出了改变，原来的为连续10分钟，即不论你这10分钟内用户是否关闭屏幕进入休眠状态，应用仍然会在后台等待10分钟完结后推出，而新的改进为假如遇到关闭屏幕休眠的情况，这后台运行的10分钟便会跟随一同休眠，剩余的后台时间将会留待用户再一次唤醒设备才计算。这样后台运行的时间仍然为10分钟，但并不连续，这样做的优点为省电

180s 想申请更长的时间，需要用到（600s）好像不用申请就有10min
beginBackgroundTaskWithExpirationHandler ->  超时回调,不管有没有完成，结束background_task任务
endBackgroundTask
一定要成对出现
只要调用了此函数系统就会允许app的所有线程继续执行，直到任务结束(1,[[UIApplicationsharedApplication]backgroundTimeRemaining] 的时间结束 2，调用endBackgroundTask)
    __block UIBackgroundTaskIdentifier background_task;
    //注册一个后台任务，告诉系统我们需要向系统借一些事件 标识在后台运行的请求的唯一标记.。
    background_task = [application beginBackgroundTaskWithExpirationHandler:^ {
        //不管有没有完成，结束background_task任务 超时回调
        [application endBackgroundTask: background_task];
        background_task = UIBackgroundTaskInvalid;
        
    }];

不限时地运行:
3.在添加UIBackgroundModes字段，是一个数组，在下面的一项string值里面填入一个。或者Capabilities中打开Background Modes。
Background Audio，这是后台的音频，这个很早之前便有，也是iOS设备中用得最多的后台应用，调用这个接口可以实现后台的音乐播放。Location Services，这是后台的定位，系统会拥有统一页面进行管理。VoIP，后台语音服务，类似Skype通话应用需要调用，可进行后台的语音通话。Newsstand，报刊杂志后台自动下载更新，其能够自动实时更新。
＊＊＊＊＊＊＊＊＊＊＊
[code][[UIApplicationsharedApplication] setKeepAliveTimeout:600 handler:^{ [selfbackgroundHandler]; }];BOOL backgroundAccepted = [[UIApplication sharedApplication] setKeepAliveTimeout:600 handler:^(void){[self backgroundHandler];//如果此时不再调用beginBackgroundTaskWithExpirationHandler，则只有10秒钟的后台执行时间了。    }];    if (backgroundAccepted) {NSLog(@"------------------------------Start new alive.");    }    [self backgroundHandler];

即在applicationDidEnterBackground加入上述代码，如果此时UIBackgroundModes不是voip，Xcode控制台会提示“Only VoIP apps can set KeepAliveTimeout”，会在9.9分钟即594秒的时候停止，挂起5秒钟左右的时间后，setKeepAliveTimeout起作用，继续执行。如果将此类功能应用在企业级APP上面，就可以实现在后台一直执行的APP。




＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊

    NSError *setCategoryErr = nil;
    NSError *activationErr  = nil;
    [[AVAudioSession sharedInstance]
     setCategory: AVAudioSessionCategoryPlayback
     error: &setCategoryErr];
    [[AVAudioSession sharedInstance]
     setActive: YES
     error: &activationErr];
    加上上面的代码后，如果你从音乐播放器切换到你的app，你会发现音乐播放器停止播放了。

＊＊＊＊＊＊＊＊＊＊＊＊

1.Capabilities 勾选 Background Modes 中的 Background fetch  
2.设定时间间隔  [[UIApplication sharedApplication] setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];
3.运行程序后， Debug 菜单中的 Simulate Background Fetch||，修改 Scheme 或新建一个 Scheme ，在 Scheme 设置的 Options 标签下选中 Background Fetch

注意
     后台获取并不是无限制的，系统在激活你的应用之后会给大概30秒的时间用于处理网络数据，所以应该尽量减少数据获取量并避免更新UI，更好的方式是在后台获取少量数据并存储然后在下次进入应用时再更新必要的UI变化
     后台调用具有不确定性，所以不要用于需要准确性的功能，比如定时提醒
     在不需要后台获取时将获取间隔设为 UIApplicationBackgroundFetchIntervalNever ，避免不必要的消耗
     不要一味的将获取间隔设为最小值，根据你的应用的需求来设置，比如只会每天变化的数据就应该设置成24*3600秒